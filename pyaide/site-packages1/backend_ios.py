"""
This is a fully functional do nothing backend to provide a template to
backend writers.  It is fully functional in that you can select it as
a backend with

  import matplotlib
  matplotlib.use('Template')

and your matplotlib scripts will (should!) run without error, though
no output is produced.  This provides a nice starting point for
backend writers because you can selectively implement methods
(draw_rectangle, draw_lines, etc...) and slowly see your figure come
to life w/o having to have a full blown implementation before getting
any results.

Copy this to backend_xxx.py and replace all instances of 'template'
with 'xxx'.  Then implement the class methods and functions below, and
add 'xxx' to the switchyard in matplotlib/backends/__init__.py and
'xxx' to the backends list in the validate_backend method in
matplotlib/__init__.py and you're off.  You can use your backend with::

  import matplotlib
  matplotlib.use('xxx')
  import matplotlib.pyplot as plt
  plt.plot([1,2,3])
  plt.show()

matplotlib also supports external backends, so you can place you can
use any module in your PYTHONPATH with the syntax::

  import matplotlib
  matplotlib.use('module://my_backend')

where my_backend.py is your module name.  This syntax is also
recognized in the rc file and in the -d argument in pylab, e.g.,::

  python simple_plot.py -dmodule://my_backend

If your backend implements support for saving figures (i.e. has a print_xyz()
method) you can register it as the default handler for a given file type

  from matplotlib.backend_bases import register_backend
  register_backend('xyz', 'my_backend', 'XYZ File Format')
  ...
  plt.savefig("figure.xyz")

The files that are most relevant to backend_writers are

  matplotlib/backends/backend_your_backend.py
  matplotlib/backend_bases.py
  matplotlib/backends/__init__.py
  matplotlib/__init__.py
  matplotlib/_pylab_helpers.py

Naming Conventions

  * classes Upper or MixedUpperCase

  * variables lower or lowerUpper

  * functions lower or underscore_separated

"""

from matplotlib._pylab_helpers import Gcf
from matplotlib.backend_bases import (
     FigureCanvasBase, FigureManagerBase, GraphicsContextBase, RendererBase)
from matplotlib.figure import Figure
from matplotlib.backends.backend_agg import FigureCanvasAgg 
from matplotlib import pyplot

from ctypes import CDLL
import ctypes
import os
import sys

def show(*, block=None):
    """
    For image backends - is not required.
    For GUI backends - show() is usually the last line of a pyplot script and
    tells the backend that it is time to draw.  In interactive mode, this
    should do nothing.
    """
    sys.stdout.flush()
    try:
      gdpath = os.environ["APPDIR"] + "/Frameworks/sixel.framework/sixel"
      gd = CDLL(gdpath)
      gd.imageARGBSixel.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_int]
      for manager in Gcf.get_all_fig_managers():
          buffer, (width, height) = manager.canvas.print_to_buffer()
          gd.imageARGBSixel(buffer, width, height)
    finally:
      if Gcf.get_all_fig_managers():
        pyplot.close('all')
    sys.stdout.flush()

# class FigureManagerTemplate(FigureManagerBase):
#     """
#     Wrap everything up into a window for the pylab interface

#     For non interactive backends, the base class does all the work
#     """
#     pass

########################################################################
#
# Now just provide the standard names that backend.__init__ is expecting
#
########################################################################

FigureCanvas = FigureCanvasAgg
FigureManager = FigureManagerBase
